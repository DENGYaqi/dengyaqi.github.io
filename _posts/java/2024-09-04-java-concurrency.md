---
title: 20分钟了解Java并发
date: 2024-09-04 10:00:00 +0800
categories: [Java]
tags: [java]
description: Java并发
pin: true
---

## 介绍
上一篇讲完了[Java容器](https://dengyaqi.github.io/posts/java-collections/)的概念与其底层数据结构原理，这一篇主要介绍Java并发的概念。


## 理论基础

### 1. 多线程的出现

由于CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:

  - CPU增加了缓存，以均衡与内存的速度差异；// 导致`可见性`问题
  - 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；// 导致`原子性`问题
  - 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致`有序性`问题

总的来说，多线程的出现是由于硬件的发展和为了提高资源利用率所提出的概念、但是不同的设备设计会导致不同并发问题的出现，也就是可见性、原子性和有序性。

#### 为什么CPU增加了缓存会导致可见性问题？
这个问题可被分为几个子问题来回答，1.CPU与内存速度的差异、2.缓存的作用与结构、3.线程的运行位置、4.可见性问题。那我们依次来回答一下 : 

1. 现代CPU的运算速度非常快，能够在极短的时间内处理大量指令。然而，与之相比，内存(RAM)的访问速度要慢得多。虽然内存比硬盘等外部存储器快得多，但它仍然跟不上CPU的处理速度。当CPU需要从内存中读取或写入数据时，往往需要等待几百个甚至几千个CPU时钟周期才能完成一次内存访问。这个延迟会导致CPU在等待数据时出现空闲状态，浪费了宝贵的计算资源。为了弥补这一差异，CPU中引入了缓存(Cache)。

   程序的运行通常具有空间局部性和时间局部性。空间局部性指的是在访问某个存储单元后，通常会访问邻近的存储单元；时间局部性指的是某些数据或指令可能会在短时间内被多次访问。缓存利用这一特点，提前将常用数据从内存中加载到缓存中。

2. 那么缓存的作用就显而易见了，也就是用于暂时保存最近使用的数据，以加速数据访问速度。缓存的层次结构（L1、L2、L3 缓存）逐层加大，但速度逐层减慢，接近内存的速度。通常由多个CPU核心共享。

3. 一个线程的运行位置是由操作系统调度程序决定的，调度程序会将线程分配到可用的CPU核心上，并管理线程的切换。

4. 可见性问题是指在多线程编程中，由于各线程在读取或修改共享变量时未及时看到其他线程的更新，导致线程之间的数据不一致性问题。换句话说，一个线程对共享变量的修改对其他线程不可见，从而造成程序逻辑错误。

最后来总结一下这个问题的答案，由于CPU比内存的处理数据的速度更快，当CPU需要从内存读写数据时需要等待很长的CPU时钟周期才能完成一次内存访问，中间的延迟导致了CPU资源浪费，所以增加了缓存，用于暂时保存最近使用的数据，以加速数据访问速度。缓存的层次结构设计是层次化的，但速度逐层减慢的，也就是L1最快、L3最慢。当缓存层次越多，数据同步延迟越大，更新的传播路径越长。也就是由于各线程在读取或修改共享变量时未及时看到其他线程的更新，导致线程之间的数据不一致性问题，从而造成程序逻辑错误。

* CPU时钟周期(Clock Cycle)是指CPU内部时钟信号完成一个完整的振荡周期的时间单位。具体可自行查阅。

#### 为什么CPU的分时复用导致了原子性问题？
同样，这个问题也可以分为几个子问题来回答。1.操作系统为什么增加了进程和线程、2.CPU的分时复用是什么、3.CPU与I/O设备的关系、4.它们之间的速度差异在哪、5.原子性问题是什么

1. 操作系统增加进程和线程的主要原因是为了提高系统的资源利用效率和响应能力，具体来说：
   
   资源共享：进程和线程允许不同任务共享计算机的资源，如CPU时间和内存。

   并发执行：进程和线程使得操作系统能够同时执行多个任务，能更好的利用多核处理器、减少等待时间，提升整体性能。

   效率：线程创建和销毁的开销比进程小，因为线程之间共享同一进程的资源，减少了上下文切换的开销。
   
   响应能力：多线程可以使程序在执行某些任务时保持响应，比如在一个图形用户界面应用中，一个线程可以处理用户输入，而另一个线程可以执行后台计算任务，从而提高用户体验。
   
   提升吞吐量：通过多线程和多进程，可以在系统中同时运行更多的任务，从而提升系统的吞吐量。例如，服务器可以通过多线程来处理多个客户端请求，从而提高服务效率。

3. CPU的分时复用(Time-sharing)是一种操作系统调度策略，旨在让多个任务(进程或线程)在同一个CPU上并发执行，从而提高系统的资源利用率和响应能力。它的核心思想是将CPU的时间划分为一个个小的时间片(time slice)，并在这些时间片之间轮流分配给不同的任务执行。

4. CPU是计算机的核心处理单元，负责执行指令和进行数据处理。I/O设备则用于与外部环境交换数据，例如输入数据、输出结果等。CPU通过I/O设备获取输入(如从键盘读取数据)，处理这些输入数据，然后通过I/O设备将处理结果输出(如将图像显示在屏幕上)。

5. 由于CPU和I/O设备之间的速度差异，CPU可能会在等待I/O操作完成时处于空闲状态，从而造成性能瓶颈。例如，CPU可能在等待硬盘读取或写入数据时无法继续执行其他任务。

6. 原子性是指在并发环境中，某个操作要么完全执行，要么完全不执行，期间不能被中断。这个问题的起因有好几种，例如

最后来总结一下这个问题的答案，操作系统通过引入进程和线程来实现CPU的分时复用，以提高系统的资源利用率和响应能力等，但是这种并发执行引发了原子性问题，也就是在

    性能瓶颈：由于I/O设备的速度远低于CPU，CPU可能会在等待I/O操作完成时处于空闲状态，造成性能瓶颈。
    并发设计：为了弥补这种速度差异，操作系统设计了异步I/O、缓冲区等机制来提高系统的整体效率。多线程和异步编程也是为了更好地利用CPU时间，并减少I/O操作对系统性能的影响。


总的来说，多线程和异步编程也是为了更好地利用CPU时间。
