---
title: 20分钟了解Java并发
date: 2024-09-04 10:00:00 +0800
categories: [Java]
tags: [java]
description: Java并发
pin: true
---

## 介绍
上一篇讲完了[Java容器](https://dengyaqi.github.io/posts/java-collections/)的概念与其底层数据结构原理，这一篇主要介绍Java并发的概念。


## 理论基础

### 1. 多线程的出现
由于CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:

  - CPU增加了缓存，以均衡与内存的速度差异；// 导致`可见性`问题
  - 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；// 导致`原子性`问题
  - 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致`有序性`问题

总的来说，多线程的出现是由于硬件的发展和为了提高资源利用率所提出的概念、但是不同的设备设计会导致不同并发问题的出现，也就是可见性、原子性和有序性。

#### 为什么CPU增加了缓存会导致可见性问题？
这个问题可被分为几个子问题来回答，1.CPU与内存速度的差异、2.缓存的作用与结构、3.线程的运行位置、4.可见性问题。那我们依次来回答一下 : 

1. 现代CPU的运算速度非常快，能够在极短的时间内处理大量指令。然而，与之相比，内存(RAM)的访问速度要慢得多。虽然内存比硬盘等外部存储器快得多，但它仍然跟不上CPU的处理速度。当CPU需要从内存中读取或写入数据时，往往需要等待几百个甚至几千个CPU时钟周期才能完成一次内存访问。这个延迟会导致CPU在等待数据时出现空闲状态，浪费了宝贵的计算资源。为了弥补这一差异，CPU中引入了缓存(Cache)。

   程序的运行通常具有空间局部性和时间局部性。空间局部性指的是在访问某个存储单元后，通常会访问邻近的存储单元；时间局部性指的是某些数据或指令可能会在短时间内被多次访问。缓存利用这一特点，提前将常用数据从内存中加载到缓存中。

2. 那么缓存的作用就显而易见了，也就是用于暂时保存最近使用的数据，以加速数据访问速度。缓存的层次结构（L1、L2、L3 缓存）逐层加大，但速度逐层减慢，接近内存的速度。通常由多个CPU核心共享。

3. 一个线程的运行位置是由操作系统调度程序决定的，调度程序会将线程分配到可用的CPU核心上，并管理线程的切换。

4. 可见性问题是指在多线程编程中，由于各线程在读取或修改共享变量时未及时看到其他线程的更新，导致线程之间的数据不一致性问题。换句话说，一个线程对共享变量的修改对其他线程不可见，从而造成程序逻辑错误。

最后来总结一下这个问题的答案，由于CPU比内存的处理数据的速度更快，当CPU需要从内存读写数据时需要等待很长的CPU时钟周期才能完成一次内存访问，中间的延迟导致了CPU资源浪费，所以增加了缓存，用于暂时保存最近使用的数据，以加速数据访问速度。缓存的层次结构设计是层次化的，但速度逐层减慢的，也就是L1最快、L3最慢。当缓存层次越多，数据同步延迟越大，更新的传播路径越长。也就是由于各线程在读取或修改共享变量时未及时看到其他线程的更新，导致线程之间的数据不一致性问题，从而造成程序逻辑错误。

* CPU时钟周期(Clock Cycle)是指CPU内部时钟信号完成一个完整的振荡周期的时间单位。具体可自行查阅。

#### 为什么CPU的分时复用导致了原子性问题？
同样，这个问题也可以分为几个子问题来回答。1.操作系统为什么增加了进程和线程、2.CPU的分时复用是什么、3.CPU与I/O设备的关系、4.它们之间的速度差异在哪、5.原子性问题是什么

1. 操作系统增加进程和线程的主要原因是为了提高系统的资源利用效率和响应能力，具体来说：
   
   资源共享：进程和线程允许不同任务共享计算机的资源，如CPU时间和内存。

   并发执行：进程和线程使得操作系统能够同时执行多个任务，能更好的利用多核处理器、减少等待时间，提升整体性能。

   效率：线程创建和销毁的开销比进程小，因为线程之间共享同一进程的资源，减少了上下文切换的开销。
   
   响应能力：多线程可以使程序在执行某些任务时保持响应，比如在一个图形用户界面应用中，一个线程可以处理用户输入，而另一个线程可以执行后台计算任务，从而提高用户体验。
   
   提升吞吐量：通过多线程和多进程，可以在系统中同时运行更多的任务，从而提升系统的吞吐量。例如，服务器可以通过多线程来处理多个客户端请求，从而提高服务效率。

3. CPU的分时复用(Time-sharing)是一种操作系统调度策略，旨在让多个任务(进程或线程)在同一个CPU上并发执行，从而提高系统的资源利用率和响应能力。它的核心思想是将CPU的时间划分为一个个小的时间片(time slice)，并在这些时间片之间轮流分配给不同的任务执行。

4. CPU是计算机的核心处理单元，负责执行指令和进行数据处理。I/O设备则用于与外部环境交换数据，例如输入数据、输出结果等。CPU通过I/O设备获取输入(如从键盘读取数据)，处理这些输入数据，然后通过I/O设备将处理结果输出(如将图像显示在屏幕上)。

5. 由于CPU和I/O设备之间的速度差异，CPU可能会在等待I/O操作完成时处于空闲状态，从而造成性能瓶颈。例如，CPU可能在等待硬盘读取或写入数据时无法继续执行其他任务。

6. 原子性是指在并发环境中，某个操作要么完全执行，要么完全不执行，期间不能被中断。这个问题的起因有多种可能性，例如操作系统的时间片轮转意味着一个线程可能在执行一个关键操作(如更新变量)时被中断。再例如多个线程或进程可能会访问和修改共享资源(如全局变量、文件等)。如果这些线程或进程没有有效的同步机制，那么在某个线程正在修改共享资源的过程中，另一个线程可能会同时访问或修改同一资源。这会导致数据不一致或错误。

最后来总结一下这个问题的答案，操作系统通过引入进程和线程来实现CPU的分时复用，以提高系统的资源利用率和响应能力等，但是这种并发执行引发了原子性问题，也就是某个操作要么完全执行，要么完全不执行，期间不能被中断。例如操作系统的时间片轮转意味着一个线程可能在执行一个关键操作(如更新变量)时被中断，操作被中断则意味着原子性问题的发生，可能会导致数据不一致或错误。

#### 为什么编译程序优化指令执行次序会导致有序性问题？
同样，这个问题也可以分为几个子问题来回答。1.编译程序如何优化指令的执行次序、2.有序性是什么、3. 从java源代码到最终实际执行的指令序列是什么样的

1. 编译程序优化指令执行次序的目的是提高代码的执行效率，减少CPU的等待时间和指令执行的延迟。主要是通过以下几个方面 : 
   
   指令调度(Instruction Scheduling) : 指令调度通过重新安排指令的执行顺序来避免CPU资源的空闲时间或资源冲突。假设有两个指令A和B，其中A的结果作为B的输入。如果A和B的执行是顺序的，B会等待A完成。通过将B移动到A的前面(如果B与A没有数据依赖)，可以在A等待期间执行B，从而提高并行度。
   
   指令级并行(Instruction-Level Parallelism) : 如果编译器发现某些指令之间没有依赖关系，它们可以被调度到不同的执行单元上，以实现并行处理，从而提高执行效率。

   还有延迟槽(Delay Slots)、基本块重排(Basic Block Reordering)、数据流分析(Data Flow Analysis)等等，就不细说了，总的来说就是编译器通过多种优化技术来改善指令执行次序，从何使得程序在实际执行时能够更好地利用CPU资源。

2. 有序性即程序执行的顺序按照代码的先后顺序执行。

![源码到指令序列](assets/img/java/java-jmm.png){: width="500" height="500" }
_从Java源代码到最终实际执行的指令序列_

3. 上述的1属于编译器重排序，2和3属于处理器重排序。

通过这三个问题，已经可以得出答案了，也就是编译程序为了减少CPU的等待时间和指令执行的延迟而优化指令执行次序，但这也导致了有序性的破坏，例如指令重排序的操，将不依赖于某个计算结果的指令移到其前面执行。再例如内存重排序，编译器可能会对内存访问操作进行重排序，以减少内存访问延迟。这可能会导致多个线程或进程看到的内存操作顺序不一致，从而影响程序的正确性。

### 2. 硬件的发展与并发问题的总结
通过解答上面三个问题，我们了解到并发问题的产生，在此总结一下。




    性能瓶颈：由于I/O设备的速度远低于CPU，CPU可能会在等待I/O操作完成时处于空闲状态，造成性能瓶颈。
    并发设计：为了弥补这种速度差异，操作系统设计了异步I/O、缓冲区等机制来提高系统的整体效率。多线程和异步编程也是为了更好地利用CPU时间，并减少I/O操作对系统性能的影响。


总的来说，多线程和异步编程也是为了更好地利用CPU时间。
