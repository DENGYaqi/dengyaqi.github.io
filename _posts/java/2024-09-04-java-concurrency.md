---
title: 20分钟了解Java并发
date: 2024-09-04 10:00:00 +0800
categories: [Java]
tags: [java]
description: Java并发
mermaid: true # 图表生成工具 : https://github.com/mermaid-js/mermaid
pin: true
---

## 介绍
上一篇讲完了[Java容器](https://dengyaqi.github.io/posts/java-collections/)的概念与其底层数据结构原理，这一篇主要介绍Java并发的概念。

## 理论基础

### 1. 多线程的出现
由于CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:

  - CPU增加了缓存，以均衡与内存的速度差异；// 导致`可见性`问题
  - 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；// 导致`原子性`问题
  - 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致`有序性`问题

总的来说，多线程的出现是由于硬件的发展和提高资源利用率、但是不同的设备设计会导致不同并发问题的出现，也就是可见性、原子性和有序性。

#### 为什么CPU增加了缓存会导致可见性问题？
由于CPU比内存的处理数据的速度更快，当CPU需要从内存读写数据时需要等待很长的[CPU时钟周期](###CPU时钟周期)才能完成一次内存访问，中间的延迟导致了CPU资源浪费，所以增加了缓存，用于暂时保存最近使用的数据，以加速数据访问速度。 

缓存的层次结构设计是层次化的，但速度逐层减慢的，也就是L1最快、L3最慢。当缓存层次越多，数据同步延迟越大，更新的传播路径越长。也就是由于各线程在读取或修改共享变量时未及时看到其他线程的更新，导致线程之间的数据不一致性问题，从而造成程序逻辑错误。也就是可见性问题的发生。

#### 为什么CPU的分时复用导致了原子性问题？
操作系统通过引入进程和线程来实现[CPU的分时复用](###CPU的分时复用)，以提高系统的资源利用率和响应能力等，但是这种并发执行引发了原子性问题，也就是某个操作要么完全执行，要么完全不执行，期间不能被中断。例如操作系统的时间片轮转意味着一个线程可能在执行一个关键操作(如更新变量)时被中断，操作被中断则意味着原子性问题的发生，可能会导致数据不一致或错误。也就是原子性问题的发生。

#### 为什么编译程序优化指令执行次序会导致有序性问题？
编译程序为了减少CPU的等待时间和指令执行的延迟而优化指令执行次序，但这也导致了有序性的破坏，例如指令重排序的操，将不依赖于某个计算结果的指令移到其前面执行。再例如内存重排序，编译器可能会对内存访问操作进行重排序，以减少内存访问延迟。这可能会导致多个线程或进程看到的内存操作顺序不一致，从而影响程序的正确性。

### 2. 并发问题的总结
通过解答上面三个问题，我们了解到并发问题的产生，在此总结一下。

|三大特性|说明|引起问题的原因顺序|
|:---|:---|:---|
|可见性|一个线程对共享变量的修改，另外一个线程能够立刻看到|CPU与内存的速度差异 -> 缓存的出现 -> 缓存的结构越复杂 -> 数据不一致性的可能越大|
|原子性|在并发环境中，某个操作要么完全执行，要么完全不执行，期间不能被中断|为提高资源利用率，线程与进程的出现 -> 为提高CPU的使用率，CPU的分时复用的出现 -> 导致操作中断等原子性问题|
|有序性|程序执行的顺序按照代码的先后顺序执行|为提高CPU执行率，编译器的指令重排 -> 导致有序性问题产生|

总的来说，多线程和异步编程都是为了更好地利用CPU资源和时间。接下来我们就说说，Java是如何解决这几个并发问题的。

## Java内存模型(Java Memory Model)
Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 : `volatile`、`synchronized`和`final`三个关键字、Happens-Before规则。这个章节总结自[深入理解Java内存模型](https://www.infoq.cn/minibook/java_memory_model)，建议大家可以看看。

![JMM总结笔记](/assets/img/java/jmm_watermark.png)
_JMM总结笔记(仅供学习使用，禁止商用)_

### 总结
Java线程之间的通信由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。JMM是一个基于顺序一致性模型设计的一个内存模型，其理念是对程序员而言，易于理解易于编程，通过实现弱内存模型来减少束缚，增加程序员优化的可能性，从而提高程序性能。

工作原理一 : 从编译器和处理器层面对指令做重排序来提高执行程序时的性能(重排序)，但是重排序都可能会导致多线程程序出现内存可见性问题，例如现代处理器都存在缓冲区，且每个处理器上的写缓冲区，仅仅对它所在的处理器可见，若处理器对指令重排序，其顺序不一定与内存实际发生的读/写操作顺序一致。为此，需要内存屏障指令来确保指令的执行顺序与保证这些变量的可见性。

工作原理二 : happens-before原则，通过这个概念来阐述操作之间的内存可见性。也就是 : 同一线程按照代码顺序执行、锁前要解锁、volatile变量的写先于读、A先于B，B先于C，则A先于C。

工作原理三 : 对于不同情况的不同处理。

1. 单线程程序 : 不会出现内存可见性问题。通过对单线程/单处理器的规定来保障 : 数据依赖性(两个操作访问同一个变量，其中一个为写操作)、as-if-serial语义(不管怎么重排序，程序的执行结果不能被改变)、 程序顺序规则(同一线程按照代码顺序执行)。

2. 正确同步的多线程程序 : 具有顺序一致性。也就是 : 一个线程中的所有操作按照程序的顺序来执行、所有线程都只能看到一个单一的操作执行顺序、每个操作都必须原子执行且立刻对所有线程可见。

3. 未同步/未正确同步的多线程程序 : 只保证最小安全性。线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值(0，null，false)。

说完JMM机制后，我们继续来看看如何正确同步多线程程序。

## 关键字: volatile、synchronized 和 final

## 词典

### CPU时钟周期
CPU时钟周期(Clock Cycle)是指CPU内部时钟信号完成一个完整的振荡周期的时间单位。

### CPU的分时复用
CPU的分时复用(Time-sharing)是一种操作系统调度策略，旨在让多个任务(进程或线程)在同一个CPU上并发执行，从而提高系统的资源利用率和响应能力。它的核心思想是将CPU的时间划分为一个个小的时间片(time slice)，并在这些时间片之间轮流分配给不同的任务执行。
