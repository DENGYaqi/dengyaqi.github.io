---
title: 20分钟了解Java
date: 2024-08-28 10:00:00 +0800
categories: [Java]
tags: [java]
description: Java基础
pin: true
---

## 介绍
本文基于[Java全栈知识体系](https://pdai.tech/md/java/basic/java-basic-lan-basic.html)和[JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-01.html)进行总结扩展，旨在快速理解Java原理。

## 面向对象

### 三大特性
1. 封装 : 包装数据。优点是 a)减少耦合、例如getter、setter，外部使用getter的时候，在变量需要变更时，我们能在getter方法内部做些变更。b)保护数据，例如变量password。 c)调解性能，可以内部变更去优化性能。提高软件可用性之类的操作都差不多。主要要去判断哪些数据需要被保护，哪些需要被放开，需要被保护的就封装起来，例如密码、身份证号码之类的，具体实现就是变量私有化，提供一个公共方法供外部使用。

```java
private String name;

public String getName() {
  return name;
}
```

2. 继承 : 需要遵守里氏替换原则，也就是任何父类(基类)可以出现的地方，子类一定可以出现。为什么要遵守这个原则？因为继承关系会给程序带来一定的侵入性，如果一个类被其他类继承，当这个类需要被修改的时候，必须要考虑到所有的子类，因为父类被修改之后，所有涉及到子类的功能，都有可能发生故障。所以继承会降低一定的可移植性，增加对象间的耦合性。所以需要遵守里氏替换原则，只有扩展类才能替换基类，才不会影响软件正常使用，也能保证父类的复用性，同时也能降低系统出错率，这样版本升级时才能保证很好的版本兼容性。

父类引用指向子类对象称为向上转型，其实就是箱子是父类，箱子里的内容是子类。

```java
Animal a = new Cat();  // 向上转型
```

3. 多态 : 同一个行为具有多个不同表现形式或形态的能力，其实就是子类重写父类的方法，再用向上转型的方式调用一下子类的这个方法，例如父类是打印机，子类是彩色打印机，子类重写一下打印方法，并将内容换成有颜色的打印，最后在Main调用一下即可，这样看起来就是父类又可以黑白打印，又可以彩印，具有多形态的打印了。

```java
class Printer {
    public void print(String content) {
        System.out.println(content); // 打印内容
    }
}

class ColorPrinter extends Printer {
    @Override
    public void print(String content) {
        System.out.println("\033[31;4m" + content + "\033[0m"); // 带有颜色打印内容
    }
}

public class Main {
    public static void main(String[] args) {
        Printer p = new ColorPrinter(); // 向上转型
        p.print(); // 彩印
    }
}
```

多态分为两种情况：编译时多态和运行时多态。如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。

运行时多态 : 也叫动态绑定，在执行期间判断引用对象的实际类型，根据实际类型判断并调用相应的属性和方法。运行时多态有三个条件，继承、覆盖(重写)、向上转型。也就是上面展示的样例内容。

## 数据类型

### 装箱拆箱和缓存池
8个基本类型boolean/1、byte/8、char/16、short/16、int/32、float/32、long/64、double/64，每个基本数据类型都对应了一个包装类型。主要说装箱拆箱，最快速的理解就是，如果把数据比作苹果，那么箱子里就有各种削皮器、小刀等等，装箱就是把苹果放到这个箱子里，别人就可以吃到削皮后的苹果或者切块后的苹果。拆箱就是直接吃苹果，或者把苹果从箱子里拿出来。也就是带有可调用方法的就是包装类型，例如Integer，可以调用valueOf(int)、parseInt()等方法，那么不带有的就是基础类型, 例如int。

包装类型的缓存机制，也就是缓存池，用于在应用程序中存储和管理临时对象或数据的内存池。主要用于减少对象的创建和销毁，池化技术的目的都差不多，像是对象池、线程池等等，都是为了对象的复用。

用Integer举例，在Java8中，Integer缓存池的大小默认为-128~127。若缓存池没有满，则会使用valueOf()判断，值在直接返回，不在则创建。若缓存池满了，则使用一些策略来处理新的缓存请求，例如LRU算法、LFU算法、FIFO、TTL等等。

```java
Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
```

## 反射
Java的反射机制是指Java语言提供的一种功能，允许在运行时动态地访问和操作类、方法、字段和构造函数等信息。通过反射，程序可以在运行时探测类的结构，并动态地调用对象的方法或访问字段。反射机制为开发者提供了极大的灵活性，但也有可能带来性能开销和安全风险。
原理是基于类加载机制，类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName("com.mysql.jdbc.Driver") 这种方式来控制类的加载，该方法会返回一个 Class 对象。

主要功能的使用方法示例 : 

```java
// 获取类信息 : 通过 Class 类获取类的信息，可以是任何对象的 Class 对象，也可以通过类字面量（如 String.class）或类加载器获取。
Class<?> clazz = Class.forName("java.lang.String");

// 获取构造函数和创建实例 : 使用 Class 对象的 getConstructor 或 getDeclaredConstructor 方法可以获取构造函数的信息。
Constructor<?> constructor = clazz.getConstructor(String.class);
Object instance = constructor.newInstance("Hello");

// 访问字段 : 使用 Class 对象的 getField 或 getDeclaredField 方法可以获取字段的信息。
Field field = clazz.getField("value");
Object value = field.get(instance);

// 访问方法 : 使用 Class 对象的 getMethod 或 getDeclaredMethod 方法可以获取方法的信息。
Method method = clazz.getMethod("length");
int length = (Integer) method.invoke(instance);

// 访问类的信息 : 通过 Class 对象可以获取类的全名、包名等信息。
String className = clazz.getName();

// 修改类的结构 : 通过反射，可以访问和修改类的私有字段和方法。
Field privateField = clazz.getDeclaredField("somePrivateField");
privateField.setAccessible(true);
privateField.set(instance, "New Value");
```

使用场景 : 

- 框架和库 : 许多Java框架使用反射来实现依赖注入、对象关系映射等功能。

```java
// 例如 Spring 框架使用反射来实现依赖注入（DI）和面向切面编程（AOP）。在运行时，Spring 会扫描类和配置文件，利用反射动态创建和管理对象，并将它们注入到需要的地方。

// Spring自动注入
@Autowired
private MyService myService;
```

- 动态代理 : Java 动态代理（java.lang.reflect.Proxy）依赖反射机制创建运行时代理对象。

```java
// Java 动态代理允许在运行时创建接口的实现代理，使用反射机制动态地处理方法调用。这在实现远程方法调用（RMI）、日志记录、性能监控等场景中非常有用。
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface MyInterface {
    void doSomething();
}

class MyInvocationHandler implements InvocationHandler {
    private final MyInterface original;

    MyInvocationHandler(MyInterface original) {
        this.original = original;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before method call");
        Object result = method.invoke(original, args);
        System.out.println("After method call");
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        MyInterface original = new MyInterfaceImpl();
        MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
            MyInterface.class.getClassLoader(),
            new Class<?>[]{MyInterface.class},
            new MyInvocationHandler(original)
        );
        proxy.doSomething();
    }
}
```

- 序列化和反序列化 : 反射可以用于在运行时处理对象的序列化和反序列化。

```java
// 例如 Java 序列化过程将对象转换为字节流并存储或传输。反射用于读取对象的字段并将其写入字节流，反序列化时则从字节流中恢复对象。

ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.dat"));
oos.writeObject(myObject);
oos.close();

ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.dat"));
MyObject myObject = (MyObject) ois.readObject();
ois.close();
```

- 开发工具 : IDE 和测试工具（如 JUnit）使用反射来检测类和方法，动态生成代码或执行测试。
```java
// 代码生成工具可以使用反射生成 Java 类、接口或方法。例如，使用反射生成与数据库表对应的 Java 类。

StringBuilder sb = new StringBuilder();
sb.append("public class ").append(className).append(" {\n");
for (Field field : fields) {
    sb.append("    private ").append(field.getType().getName()).append(" ").append(field.getName()).append(";\n");
}
sb.append("}");
String generatedClass = sb.toString();
```

## 泛型
泛型的本质是为了参数化类型，类似于形参，调用时传参才知道具体的类型是什么。
适用于多种数据类型执行相同的代码的场景。
