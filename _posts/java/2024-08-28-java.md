---
title: 20分钟了解Java
date: 2024-08-28 10:00:00 +0800
categories: [Java]
tags: [java]
description: JVM基础
pin: true
---

## 介绍
本文基于[Java全栈知识体系](https://pdai.tech/md/java/basic/java-basic-lan-basic.html)和[JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-01.html)进行总结扩展，旨在快速理解Java原理。

## 面向对象

### 三大特性
1. 封装 : 包装数据。优点是 a)减少耦合、例如getter、setter，外部使用getter的时候，在变量需要变更时，我们还能在getter方法内部做些变更，但是如果外部直接调用该变量，就没有回旋的余地了。b)保护数据，例如变量password，直接被人看到密码就不大好了吧。 c)调解性能，也是跟a差不多，可以内部变更去优化性能。提高软件可用性之类的操作其实都是差不多的。主要要去判断哪些数据需要被保护，哪些需要被放开，需要被保护的就封装起来，例如密码、身份证号码之类的，具体实现就是变量私有化，提供一个公共方法供外部使用。

```java
private String name;

public String getName() {
  return name;
}
```

2. 继承 : 字面意思，只不过需要遵守里氏替换原则，也就是任何父类(基类)可以出现的地方，子类一定可以出现。为什么要遵守这个原则？因为继承关系会给程序带来一定的侵入性，如果一个类被其他类继承，当这个类需要被修改的时候，必须要考虑到所有的子类，因为父类被修改之后，所有涉及到子类的功能，都有可能发生故障。所以继承会降低一定的可移植性，增加对象间的耦合性。所以需要遵守里氏替换原则，只有扩展类才能替换基类，才不会影响软件正常使用，也能保证父类的复用性，同时也能降低系统出错率，这样版本升级时才能保证很好的版本兼容性。

父类引用指向子类对象称为向上转型，其实就是箱子是父类，箱子里的内容是子类。

```java
Animal a = new Cat();  // 向上转型
```

3. 多态 : 同一个行为具有多个不同表现形式或形态的能力，其实就是子类重写父类的方法，再用向上转型的方式调用一下子类的这个方法，例如父类是打印机，子类是彩色打印机，子类重写一下打印方法，并将内容换成有颜色的打印，最后在Main调用一下即可，这样看起来就是父类又可以黑白打印，又可以彩印，具有多形态的打印了。

```java
class Printer {
    public void print(String content) {
        System.out.println(content); // 打印内容
    }
}

class ColorPrinter extends Printer {
    @Override
    public void print(String content) {
        System.out.println("\033[31;4m" + content + "\033[0m"); // 带有颜色打印内容
    }
}

public class Main {
    public static void main(String[] args) {
        Printer p = new ColorPrinter(); // 向上转型
        p.print(); // 彩印
    }
}
```

多态分为两种情况：编译时多态和运行时多态。如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。

运行时多态 : 也叫动态绑定，在执行期间判断引用对象的实际类型，根据实际类型判断并调用相应的属性和方法。运行时多态有三个条件，继承、覆盖(重写)、向上转型。也就是上面展示的样例内容。

## 数据类型

### 装箱拆箱
8个基本类型就不说了，每个基本数据类型都对应了一个包装类型。主要说说装箱拆箱，最快速的去理解就是，如果把数据比作苹果，那么箱子里就有各种削皮器、小刀等等，装箱就是把苹果放到这个箱子里，别人就可以吃到削皮后的苹果或者切块后的苹果。拆箱就是直接吃苹果，或者把苹果从箱子里拿出来。也就是带有可调用方法的就是包装类型，例如Integer，可以调用valueOf(int)、parseInt()等方法，那么不带有的就是基础类型, 例如int。

包装类型的缓存机制，也就是缓存池，主要用于减少对象的创建和销毁，其实池化技术的目的差不多都是这个，像是对象池、线程池等等，都是为了对象的复用。那回到这个包装类的缓存池也一样，直接用这池子里已存在变量。

## 泛型
泛型的本质是为了参数化类型，类似于形参，调用时传参才知道具体的类型是什么。
适用于多种数据类型执行相同的代码的场景。
