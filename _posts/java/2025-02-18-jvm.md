---
title: JVM原理解析与实战
date: 2025-02-18 10:00:00 +0800
categories: [Java]
tags: [java, jvm]
description: JVM
pin: true
---

# JVM原理解析与实战

## 一、JVM介绍

### 1.JVM是什么

Java Virtual Machine(Java虚拟机)是java程序实现跨平台的一个重要的工具(部件)。

![JVM全貌](/assets/img/java/jvm/JVM是什么.png){: width="300" height="300" }
_JVM全貌_

HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是 目前使用范围最广的Java虚拟机。

只要装有JVM的平台，都可以运行java程序。那么Java程序在JVM上是怎么被运行的? 

通过介绍以下JVM的三个组成部分，就可以了解到JVM内部的工作机制

- 类加载系统:负责完成类的加载
- 运行时数据区:在运行Java程序的时候会产生的各种数据会保存在运行时数据区
- 执行引擎:执行具体的指令(代码)

![JVM组件](/assets/img/java/jvm/JVM是什么2.png){: width="300" height="300" }
_JVM组件_

### 2.学习目标

我们学JVM相关知识的目的是为了充分理解jvm内部的工作流程，来掌握如何通过相应的参数配置，实现JVM的调优。

## 二、类加载系统

### 1.类的加载过程

一个类被加载进JVM中要经历哪几个过程

- 加载: 通过io流的方式把字节码文件读入到jvm中(方法区==jdk8以后叫元空间)
- 校验: 通过校验字节码文件的头4位的16进制是否是java魔数cafebabe
- 准备: 为类中的静态部分开辟空间并赋初始化值，例如public static int count = 10;
- 解析: 将符号引用转换成直接引用。——静态链接，例如 jvmAnalyze.add()的.add()相当于一次引用。动态连接表示代码执行到该位置才会去寻找对应指令。
- 初始化: 为类中的静态部分赋指定值并执行静态代码块。

类被加载后，类中的类型信息、方法信息、属性信息、运行时常量池、类加载器的引用等信 息会被加载到元空间中。

常量值属于不会被回收的空间。jdk8以后把常量值移到了堆内。

```shell
# 反编译字节码文件，可以看到更详细的内容
javap -v xxx.class
```
constant pool 常量值

### 2.类加载器

类是谁来负载加载的?——类加载器

- Bootstrap ClassLoader 启动类加载器:负载加载jre/lib下的核心类库中的类，比如 rt.jar、charsets.jar
- ExtClassLoader 扩展类加载器:负载加载jre/lib下的ext目录内的类

```text
ext 加载路径:System.getProperty("java.ext.dirs"); 
```

- AppClassLoader 应用类加载器:负载加载用户自己写的类

```text
app 加载路径:System.getProperty("java.class.path"); 
```

- 自定义类加载器:自己定义的类加载器，可以打破双亲委派机制。
 
![类加载过程](/assets/img/java/jvm/类加载器.png){: width="300" height="300" }
_类加载过程，com.qf.JVMAnalyze.class是用户写的类_

```java
ClassLoader classLoader1 = Object.class.getClassLoader(); // java自身类的类加载器
ClassLoader classLoader2 = EyentID.class.getClassLoader(); // java扩展类的类加载器
ClassLoader classLoader3 = LoadClassAnalyze1.class.getClassLoader(); // 用户自己写的类加载器

System.out.println("classLoader1:" + classLoader1);
System.out.println("classLoader2:" + classLoader2);
System.out.println("classLoader3:" + classLoader3);
```

```shell
classLoader1:null
classLoader2:sun.misc.Launcher$ExtClassLoader@5e2de80c
classLoader3:sun.misc.Launcher$AppClassLoader@18b4aac2
```

可以看到java自身类的类加载器是看不到的，因为用c++编写的，扩展类的类加载器可以看到是ExtClassLoader进行加载的，用户自身的类加载器是AppClassLoader进行加载的。

## 三、双亲委派机制

### 1.双亲委派机制介绍

### 2.为什么要有双亲委派机制

### 3.双亲委派机制核心源码

### 4.全盘委托机制

### 5·自定义类加载器实现双亲委派机制

## 四、运行时数据区

### 1.运行时数据区介绍

### 2.程序在执行时运行时数据区中的内存变化

## 五、对象的创建流程

### 1.对象创建流程

### 2.类加载校验

### 3.分配内存

### 4.设置初值

### 5.设置对象头及指针压缩

### 6.执行init方法

## 六、垃圾回收机制

### 1.对象成为垃圾的判断依据

### 2.对象中的finalize方法

### 3.对象的逃逸分析

## 七、垃圾回收算法

### 1、标记清除算法、复制算法、标记整理算法

### 2.分代回收算法

### 3.对象进入到老年代的条件

## 八、垃圾回收器

### 1.Serial收集器（—XX：+UseSerialGC—XX：+UseSerialOldGC）

### 2.Parallel收集器(-XX:+UseParallelGC.-XX:+UseParallelOldGC)

### 3.ParNew收集器（—XX：+UseParNewGC）

### 4.CMS收集器(-XX:+UseConcMarkSweepGC)

### 5.三色标记算法

### 6.垃圾收集器组合方案

## 九、JVM调优实战

### 1.JVM调优的核心参数

### 2.JVM调优实战

### 3.调优的关键点

### 4.结合垃圾收集器的调优策略

### 作业
