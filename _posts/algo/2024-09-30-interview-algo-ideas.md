---
title: 面试算法解题思路
date: 2024-09-30 10:00:00 +0800
categories: [Algo]
tags: [algo]
description: 算法思路
pin: true
---

## 介绍
本文主要分为三个部分，读懂题目，选择解答，组织解答，代码部分只包含算法框架，旨在面试时能给面试官提供一个最优算法解的语言描述。建议读一遍有个印象之后再去看看大厂的算法题。

1. 读懂题目主要是算法词汇部分，只要能看懂题目，基本上这个算法题已经解了一半了。

2. 选择解答则是了解各类算法框架的核心后，选一个最符合题目的算法解答，例如动态规划一定是用于解最值的，也就是动态规划问题一定会具备"最优子结构"，例如从起点到终点最短路径是哪条。

3. 组织解答则是根据选好的算法核心和具体的题目，进行应对和调整，因为算法核心并不一定能完全的对应上题目的解答，此时还需要对算法核心做一些微小的调整。

## 基础词汇
很多时候看不懂题目是因为不了解某个词汇，下面有leetcode题目中最常见的词汇与其定义。

1. 序列 : 偏向数学概念，有序的元素集合, 有限或无限, 每个元素都有一个特定的位置或索引，如数列(自然数序列 1,2,3,4,...1,2,3,4,...)、字符串(由一系列字符组成的序列，如 "hello")、数组( [3,1,4,1,5])。下方表格只记录一些典型的，例如非递增序列，同理也会有非递减序列，原理是一样的，就不重复记录了。
2. 数组 : 存储多个相同类型的元素，连续内存地址。
3. 字符串 : 由一系列字符组成的有限序列组成，字符串的长度是其中包含的字符数，其中的字符按一定顺序排列，顺序是不可改变的。
4. 升序/降序 : 升序是从小到大的排序方式，元素按从低到高的顺序排列。降序则相反。

### 关键词 : 子..(Sub..)
都有从原序列中选取部分元素的含义，但在选取时对元素顺序和连续性的要求有所不同。

|名称|定义|连续性|元素顺序|举例|
|:---|:---|:---|:---|:---|
|子序列|从原序列中按照顺序选取的元素|不一定连续|元素顺序必须保持一致|给定数组或字符串 [1, 2, 3, 4, 5] 或 "abcde"，子序列可以是 [1, 3, 5] 或 "ace"，因为虽然这些元素不连续，但它们的顺序和原序列一致|
|子数组|从一个数组中选取的连续元素的集合|连续|元素顺序必须保持一致|给定数组 [1, 2, 3, 4, 5]，其子数组包括 [1, 2]、[2, 3, 4] 等，但不能是 [1, 3, 5]，因为它们不是连续的|
|子段|子段是一个序列或数组的连续子集|连续|元素之间必须相邻|给定数组 [1, 2, 3, 4, 5]，子段可以是 [1, 2]、[3, 4, 5]，但不能是 [1, 3, 5]，因为它们不相邻|
|子串|从一个字符串中选取的连续字符的集合|连续|元素顺序必须保持一致|给定字符串 "abcdef"，其子串可以是 "abc"、"cde"，但不能是 "ace"，因为字符 "a"、"c" 和 "e" 不连续|

### 关键词 : 递增..(Inc..)
元素值随着索引的增加而增大的性质。

### 关键词 : 公共..(Common..)
多组数据结构中相同的内容。

### 关键词 : 连续..(Contig..)
一般指的是元素之间的顺序是连续的。

|名称|定义|连续性|元素顺序|举例|
|:---|:---|:---|:---|:---|
|连续子段|数组或字符串中相邻的一部分元素。一般指的是一个子段，其中元素是连续的|连续|不定|给定数组 arr = [1, 2, 3, 4, 5]，以下是从中提取的几个连续子段：[3, 4, 5]：包含三个元素的连续子段。[2, 3]：包含两个元素的连续子段|

### 关键词组合

序列

|名称|定义|
|:---|:---|
|连续子序列(Contiguous Subsequence)|序列中的元素不需要是连续的，只需要保持相对顺序；而连续子序列的元素必须是连续的|
|非递增序列(Non-increasing Sequence)|序列中的元素按不增顺序排列|
|最长公共子序列(Longest Common Subsequence, LCS)|两个或多个序列中最长的按顺序出现的公共子序列|
|最长递增子序列(Longest Increasing Subsequence, LIS)|一个最长的子序列，序列中的元素是按严格递增的顺序排列的|
|序列求和(Sequence Sum)|序列中所有元素的总和|
|切片(Slicing)|从一个序列中提取出特定部分的操作|

数组

|名称|定义|
|:---|:---|

字符串

|名称|定义|
|:---|:---|

## 算法基础

- 时间复杂度 : 衡量一个算法的执行效率，用大O表示法表示(类似 O(1), O(n^2))，都是估计值，不需要精确计算，看 for 循环的嵌套层数即可。

- 空间复杂度 : 衡量算法的内存消耗，也是用大O表示法，看算法声明了多少空间来存储数据。

- 算法优化 : 拿空间换时间。

## 算法核心框架

![算法核心框架样例](/assets/img/algo/algo_framework_watermark.png)
_算法核心框架样例(仅供学习使用，禁止商用)_

算法核心框架 = 数据结构 + 基本操作 + 聪明穷举。最终目的都是为了在不同应用场景下尽可能高效的增删改查。

数据结构最底层的存储方式只有两种 : 数组(顺序存储，内存地址连续)和链表(链式存储，内存地址不连续)，其他的数据结构都是由此发展。

基本操作无非就是遍历 + 访问，其实就是增删改查，也有两种形式 : 线性(for/while)和非线性(递归)。

聪明的穷举的关键点在于无遗漏和无冗余。

1. 数组框架
```java
void traverse(int[] arr){
  for(int i = 0; i < arr.length; i++){
    // 迭代访问arr[i]
  }
}
```

2. 递归框架
- 确定递归函数的参数和返回值
- 确定终止条件
- 确定单层递归的逻辑(处理当前层逻辑)
- (非必要)回溯：有时需要在递归返回时恢复之前的状态，常见于回溯问题。

```java
public void recursiveFunction(int level, int param) {
    // 确定终止条件
    if (level > MAX_LEVEL) {
        return;
    }

    // 处理当前层逻辑
    process(level, param);

    // 进入下一层递归
    recursiveFunction(level + 1, newParam);

    // 如果有需要，恢复当前层状态（回溯）
}
```

2. 链表框架
有迭代访问(for)和递归访问两种形式。

```java
void traverse(ListNode head){
  for(ListNode p = head; p != null; p = p.next){
    // 迭代访问p.val
  }
}

void traverse(ListNode head){
  // 递归访问head.val
  traverse(head.next);
}
```

### 二叉树框架
只要涉及递归的问题，都是树的问题。大部分算法技巧，本质上都是树的遍历问题。

```java
void traverse(TreeNode root){
  // 前序位置
  traverse(root.left);
  // 中序位置
  traverse(root.right);
  // 后序位置
}
```

### 动态规划框架

## 微调思路

## 参考资料

1. [labuladong的算法笔记](https://labuladong.online/algo/home/)

2. [代码随想录](https://programmercarl.com/)
